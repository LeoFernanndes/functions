# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gHDLGwRq_VQCNErwPqaghii8QWrrh3i0
"""


def naive_data_preparation(dataset):
    '''

    Function used to fill in the gaps with mean for continous features and mode for the discrete ones and apply
    naive label encoding without concerns about the suitability of dummy variables.

    '''
    import pandas as pd
    from sklearn.preprocessing import LabelEncoder

    for column in dataset.columns:
        if dataset[column].dtype == 'object':
            dataset[column] = dataset[column].astype('str')
            dataset[column].fillna(dataset[column].mode(), inplace=True)

        elif dataset[column].dtype == 'int':
            dataset[column].fillna(dataset[column].mode(), inplace=True)

        elif dataset[column].dtype == 'float':
            dataset[column].fillna(dataset[column].mean(), inplace=True)

        else:
            dataset[column] = dataset[column].astype('str')
            dataset[column].fillna(dataset[column].mode(), inplace=True)

    le = LabelEncoder()

    for column in dataset.columns:
        if dataset[column].dtype == 'object':
            dataset[column] = le.fit_transform(dataset[column])


def classifier_accuracy_graph(dataset, classifier, iterations=5):
    '''
    docstring
    '''

    from sklearn.metrics import accuracy_score
    from sklearn.model_selection import train_test_split
    import matplotlib.pyplot as plt
    import pandas as pd

    colunas = dataset.columns

    accuracy_list_ = []
    x_axis_ = []
    y_axis_ac = []
    colunas_ = []

    for feat in colunas[:-1]:

        colunas_.append(feat)
        accuracy_list_ = []

        for it in range(iterations):

            x_train_, x_test_, y_train_, y_test_ = train_test_split(
                dataset[colunas_], dataset[colunas[-1]], test_size=0.25, random_state=it)

            '''

      clf_ = LinearDiscriminantAnalysis(n_components=None, priors=None, shrinkage=None,
                            solver='svd', store_covariance=False, tol=0.0001)

      '''

            clf_ = classifier

            clf_.fit(x_train_, y_train_)
            y_pred_ = clf_.predict(x_test_)

            accuracy_list_.append(accuracy_score(y_pred_, y_test_))

        x_axis_.append(feat)
        y_axis_ac.append(pd.Series(accuracy_list_).mean())

    plt.title(str(classifier).split('(')[0])
    plt.plot(x_axis_, y_axis_ac)
    plt.xticks(rotation=45)
    plt.grid()
    plt.show()


def classification_stakcing_model(dataset, model, df_resultados, iterations=7, folds=20):

            #df_resultados_ = pd.DataFrame({'PassengerId': titanic['PassengerId']})

    import pandas as pd
    from sklearn.model_selection import train_test_split
    from sklearn.metrics import accuracy_score

    x_axis_ = []
    y_axis_ac = []

    for fold in range(folds):

        accuracy_list_ = []
        f1_list_ = []

        for it in range(iterations):

            x_train_, x_test_, y_train_, y_test_ = train_test_split(
                dataset[dataset.columns[0:-1]], dataset[dataset.columns[-1]], test_size=0.25, random_state=fold * it)

            clf_ = model

            clf_.fit(x_train_, y_train_)
            y_pred_ = clf_.predict(x_test_)

            accuracy_list_.append(accuracy_score(y_pred_, y_test_))

            dataframe_ = pd.DataFrame({it: y_pred_}, index=y_test_.index)
            df_resultados = pd.concat([df_resultados, dataframe_], axis=1)

    final = df_resultados.mode(axis=1)[0]
    final_ = accuracy_score(final, dataset[dataset.columns[-1]])

    print('Accuracy score {} for {}'.format(
        final_, (str(model).split('(')[0])))


def classification_stakcing_model_test(dataset, test_dataset, model, df_resultados, iterations=7, folds=20):

    #df_resultados_ = pd.DataFrame({'PassengerId': titanic['PassengerId']})

    from sklearn.model_selection import train_test_split
    from sklearn.metrics import accuracy_score
    import pandas as pd

    colunas = dataset.columns[0: -1]

    for fold in range(folds):

        for it in range(iterations):

            x_train_, x_test_, y_train_, y_test_ = train_test_split(
                dataset[dataset.columns[0:-1]], dataset[dataset.columns[-1]], test_size=0.33, random_state=((it + it**2) * fold))

            clf_ = model

            clf_.fit(x_train_, y_train_)
            y_pred_ = clf_.predict(test_dataset[colunas])

            dataframe_ = pd.DataFrame({it: y_pred_}, index=test_dataset.index)
            df_resultados = pd.concat([df_resultados, dataframe_], axis=1)

    return df_resultados.mode(axis=1)[0]


def cross_val_binnary_classification(dataframe, classifier, iterations=100, plot=True):

    import matplotlib.pyplot as plt
    from sklearn.metrics import f1_score, accuracy_score
    from sklearn.model_selection import train_test_split
    import pandas as pd
    import numpy as np

    x_axis = []
    y_axis_f1 = []
    y_axis_accuracy = []

    for i in range(iterations):

        x_train, x_test, y_train, y_test = train_test_split(dataframe[dataframe.columns[:-1]],
                                                            dataframe[dataframe.columns[-1]], test_size=0.3, random_state=i * 3)

        clf = classifier

        clf.fit(x_train, y_train)

        y_pred = clf.predict(x_test)

        x_axis.append(i)
        y_axis_accuracy.append(accuracy_score(y_pred, y_test))
        y_axis_f1.append(f1_score(y_pred, y_test))

    x_axis_s = pd.Series(x_axis)
    y_axis_accuracy_s = pd.Series(y_axis_accuracy)
    y_axis_f1_s = pd.Series(y_axis_f1)

    if plot == True:
        plt.title(str(classifier).split('(')[0])
        plt.plot(x_axis_s, y_axis_accuracy_s)
        plt.plot(x_axis_s, y_axis_f1_s)
        plt.show()

        print('Accuracy: {} std {}, f1: {} std {}'.format(y_axis_accuracy_s.mean(
        ), y_axis_accuracy_s.std(), y_axis_f1_s.mean(), y_axis_f1_s.std()))

    elif plot == False:
        print(str(classifier).split('(')[0])
        print('Accuracy: {} std {}, f1: {} std {}'.format(y_axis_accuracy_s.mean(
        ), y_axis_accuracy_s.std(), y_axis_f1_s.mean(), y_axis_f1_s.std()))

    else:
        print(str(classifier).split('(')[0])
        print('Accuracy: {} std {}, f1: {} std {}'.format(y_axis_accuracy_s.mean(
        ), y_axis_accuracy_s.std(), y_axis_f1_s.mean(), y_axis_f1_s.std()))
